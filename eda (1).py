# -*- coding: utf-8 -*-
"""EDA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jfN7czqIIFaVGginJ3V7MySdy3NBrkpr
"""

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.impute import SimpleImputer
from datetime import datetime
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.preprocessing import MinMaxScaler

# Load the cleaned dataset
df = pd.read_csv("Cleaned_Bosch_Dataset.csv")

print(df.columns)

data = pd.read_excel("Bosch Dataset.xlsx", engine="openpyxl")

# Rename relevant columns for clarity
data.rename(columns={
    "Description": "Tool_Description",
    "Brand (Make)": "Brand",
    "Tag": "Tag_ID",
    "Model/Part No": "Model_Part_No",
    "Serial / Id no": "Serial_No",
    "Range": "Range",
    "External": "Ext_Tolerance_Limit",
    "Internal": "Int_Tolerance_Limit",
    "In USE?\n(Y=Yes;\n N=No)": "In_Use",
    "Actual\nCalibration\nInterval\n(No. of Yr)": "Calibration_Interval_Years",
    "Last \nCalibration": "Last_Calibration_Date",
    "Calibration \nDue": "Next_Calibration_Date",
    "Remaining mths before Calibration due date ": "Months_Remaining",
    "1. External Cal:\n In-House / Lab" : "Cal_type",
    "Calibration Report\nNumber ": "Calibration_Report_No",
    "Action for Renewal Reminder": "Action",
}, inplace=True)

# Ensuring important columns remain unchanged
important_columns = ["Range", "Model_Part_Number", "Tolerance"]

for col in important_columns:
        if col in df.columns and col in data.columns:
            df[col] = data[col].astype(str)  # Preserve original format

print(df.head())

# Convert date columns to datetime
df["Last_Calibration_Date"] = pd.to_datetime(df["Last_Calibration_Date"], errors="coerce")
df["Next_Calibration_Date"] = pd.to_datetime(df["Next_Calibration_Date"], errors="coerce")

print("\n Converted Date Columns to Datetime")
print(df[["Last_Calibration_Date", "Next_Calibration_Date"]].head())

# Convert 'Months_Remaining' to numeric
df["Months_Remaining"] = pd.to_numeric(df["Months_Remaining"], errors="coerce")

print("\n Converted 'Months_Remaining' to Numeric")
print(df["Months_Remaining"].head())

# Summary Statistics
print("\n Dataset Shape:", df.shape)
print("\n Column Data Types:\n", df.dtypes)
print("\n Missing Values:\n", df.isnull().sum())
print("\n Summary Statistics:\n", df.describe())

# Fill missing `Tolerence Limit` with "Unknown" instead of dropping
df["Tolerence Limit"].fillna("Unknown", inplace=True)

print("\n Filled missing 'Tolerence Limit' values with 'Unknown'")

# Check if there are any missing values to impute
if df["Last_Calibration_Days"].isnull().any():
    lr = LinearRegression()
    train_data = df.dropna(subset=["Last_Calibration_Days"])
    lr.fit(train_data[["Calibration_Interval_Years", "Months_Remaining"]], train_data["Last_Calibration_Days"])

    # Predict only for rows with missing 'Last_Calibration_Days'
    imputation_data = df[df["Last_Calibration_Days"].isnull()][["Calibration_Interval_Years", "Months_Remaining"]]
    imputed_values = lr.predict(imputation_data)

    df.loc[df["Last_Calibration_Days"].isnull(), "Last_Calibration_Days"] = imputed_values  # Assign imputed values to selected rows
    df["Last_Calibration_Date"] = df["Last_Calibration_Date"].min() + pd.to_timedelta(df["Last_Calibration_Days"], unit="D")

    print("\n Imputed missing 'Last_Calibration_Days' values using Linear Regression")
else:
    print("\n No missing 'Last_Calibration_Days' values to impute.")

# Check if there are any missing values to impute
if df["Next_Calibration_Days"].isnull().any():
    lr = LinearRegression()
    train_data = df.dropna(subset=["Next_Calibration_Days"])
    lr.fit(train_data[["Calibration_Interval_Years", "Months_Remaining"]], train_data["Next_Calibration_Days"])

    imputation_data = df[df["Next_Calibration_Days"].isnull()][["Calibration_Interval_Years", "Months_Remaining"]]
    imputed_values = lr.predict(imputation_data)

    df.loc[df["Next_Calibration_Days"].isnull(), "Next_Calibration_Days"] = imputed_values
    df["Next_Calibration_Date"] = df["Next_Calibration_Date"].min() + pd.to_timedelta(df["Next_Calibration_Days"], unit="D")

    print("\n Imputed missing 'Next_Calibration_Days' values using Linear Regression")
else:
    print("\n No missing 'Next_Calibration_Days' values to impute.")

# Fill missing `Tolerence Limit` with "Unknown" instead of dropping
df["In_Use"].fillna("Unknown", inplace=True)

# Fill Missing Dates with Median
df["Last_Calibration_Date"].fillna(df["Last_Calibration_Date"].median(), inplace=True)
df["Next_Calibration_Date"].fillna(df["Next_Calibration_Date"].median(), inplace=True)

# Recalculate `Months_Remaining`
df["Months_Remaining"] = (df["Next_Calibration_Date"] - datetime.today()).dt.days / 30
df["Months_Remaining"].fillna(df["Months_Remaining"].median(), inplace=True)

# Ensure datetime conversion
df["Last_Calibration_Date"] = pd.to_datetime(df["Last_Calibration_Date"], errors="coerce")
df["Next_Calibration_Date"] = pd.to_datetime(df["Next_Calibration_Date"], errors="coerce")

# Create new time-based features
df["Days_Since_Last_Calibration"] = (datetime.today() - df["Last_Calibration_Date"]).dt.days
df["Days_Until_Next_Calibration"] = (df["Next_Calibration_Date"] - datetime.today()).dt.days
df["Calibration_Overdue"] = df["Days_Until_Next_Calibration"] < 0  # Flag overdue calibrations

print("\n Created Time-Based Features:")
print(df[["Days_Since_Last_Calibration", "Days_Until_Next_Calibration", "Calibration_Overdue"]].head())

# Fill `P.I.C.` and `Calibration_Report_No`
df["P.I.C."].fillna(df["P.I.C."].mode()[0], inplace=True)
df["Calibration_Report_No"].fillna("Unknown", inplace=True)

# Summary Statistics after data handling
print("\n Dataset Shape:", df.shape)
print("\n Column Data Types:\n", df.dtypes)
print("\n Missing Values:\n", df.isnull().sum())
print("\n Summary Statistics:\n", df.describe())

# Show summary of numerical columns
print("\n Summary Statistics (Numerical Data):\n", df.describe())

# Histogram of Numerical Features
df[["Calibration_Interval_Years", "Months_Remaining"]].hist(figsize=(10, 5), bins=20, edgecolor="black")
plt.suptitle("Distribution of Numerical Features", fontsize=14)
plt.show()

# Correlation Heatmap
plt.figure(figsize=(6, 4))
sns.heatmap(df[["Calibration_Interval_Years", "Months_Remaining"]].corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Feature Correlation Heatmap")
plt.show()

# Exploratory Data Analysis (EDA)
# Distribution of Calibration Intervals
plt.figure(figsize=(10, 5))
sns.histplot(df["Calibration_Interval_Years"].dropna(), bins=10, kde=True)
plt.title("Distribution of Calibration Intervals (Years)")
plt.xlabel("Calibration Interval (Years)")
plt.ylabel("Frequency")
plt.show()

# Trend of upcoming calibration due dates
plt.figure(figsize=(12, 6))
df["Next_Calibration_Date"].dropna().value_counts().sort_index().plot(kind="line", marker='o', linestyle='-')
plt.title("Trend of Calibration Due Dates Over Time")
plt.xlabel("Date")
plt.ylabel("Number of Calibrations Due")
plt.xticks(rotation=45)
plt.show()

# Histogram of Time-Based Features
plt.figure(figsize=(12, 5))
df[["Days_Since_Last_Calibration", "Days_Until_Next_Calibration"]].hist(bins=30, edgecolor="black", layout=(1,2), figsize=(12,4))
plt.suptitle("Distribution of Time-Based Features", fontsize=14)
plt.show()

# Boxplot to Check for Outliers
plt.figure(figsize=(8, 4))
sns.boxplot(data=df[["Days_Since_Last_Calibration", "Days_Until_Next_Calibration"]])
plt.title("Boxplot of Time-Based Features")
plt.show()

# Correlation Heatmap
plt.figure(figsize=(8, 5))
sns.heatmap(df[["Calibration_Interval_Years", "Months_Remaining", "Days_Since_Last_Calibration", "Days_Until_Next_Calibration"]].corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Feature Correlation Heatmap")
plt.show()

# Boxplot of remaining months before calibration is due
plt.figure(figsize=(8, 5))
sns.boxplot(x=df["Months_Remaining"].dropna())
plt.title("Boxplot of Remaining Months Before Calibration Due")
#Rotate 90 degree
plt.xticks(rotation=90)
plt.xlabel("Months Remaining")
plt.show()

# Anomaly Detection - Identify Outliers in Calibration Intervals
plt.figure(figsize=(8, 5))
sns.boxplot(x=df["Calibration_Interval_Years"].dropna())
plt.title("Boxplot of Calibration Interval (Years) - Outlier Detection")
plt.xlabel("Calibration Interval (Years)")
plt.show()

# Before Scaling
plt.figure(figsize=(10, 4))
df[["Calibration_Interval_Years", "Months_Remaining"]].hist(bins=20, edgecolor="black", layout=(1,2), figsize=(10,4))
plt.suptitle("Feature Distribution Before Scaling", fontsize=14)
plt.show()

# Apply Scaling

scaler = MinMaxScaler()
num_cols = ["Calibration_Interval_Years", "Months_Remaining", "Days_Since_Last_Calibration", "Days_Until_Next_Calibration"]
df[num_cols] = scaler.fit_transform(df[num_cols])

# After Scaling
plt.figure(figsize=(10, 4))
df[num_cols].hist(bins=20, edgecolor="black", layout=(1,4), figsize=(12,4))
plt.suptitle("Feature Distribution After Scaling", fontsize=14)
plt.show()

# Create a new column to flag overdue calibrations

# Create Time-Based Features
df["Days_Since_Last_Calibration"] = (datetime.today() - df["Last_Calibration_Date"]).dt.days
df["Days_Until_Next_Calibration"] = (df["Next_Calibration_Date"] - datetime.today()).dt.days

df["Overdue_Flag"] = df["Months_Remaining"] < 0

# Count overdue tools
print("\n Number of Overdue Tools:", df["Overdue_Flag"].sum())

# Display overdue tools
print("\n Overdue Tools:")
print(df[df["Overdue_Flag"] == True][["Tool_Description", "Next_Calibration_Date", "Months_Remaining"]])

# Identify categorical columns
cat_cols = df.select_dtypes(include=["object"]).columns.tolist()
print("\nðŸ”¹ Categorical Columns:", cat_cols)

# Show unique values in categorical columns
print("\nðŸ”¹ Unique Values in Categorical Columns:")
for col in df.select_dtypes(include=['object']).columns:
    print(f"{col}: {df[col].nunique()} unique values")

# Label Encoding for Binary & Ordinal Features
label_encoders = {}
binary_cols = ["In_Use", "Tolerence Limit"]

for col in binary_cols:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])
    label_encoders[col] = le  # Store for later decoding

# One-Hot Encoding for Nominal Categorical Variables
one_hot_cols = ["Brand", "Calibrator"]
df = pd.get_dummies(df, columns=one_hot_cols, drop_first=True)  # Avoid multicollinearity

print("\n Categorical Features Encoded Successfully!")
print(df.head())

#Verifying Encoding

print("\n Final Dataset Columns:", df.columns)